# Transactions

A list of Transaction types are summarized as follows, and the implementation
details are explained in more detail below. Some transaction types are
currently disabled on the network as the current node version does not support
them fully, although we have planned for and are actively developing those
features for later versions.

[table]

| Name                                                 |  Type  | Description                                           |  Available      |  Fee       |
|------------------------------------------------------|--------|-------------------------------------------------------|:---------------:| ----------:|
| [Send](#send-transaction)                            | `0`    | Send RISE from one address to another                 |  **✓**          |  0.1 RISE  |
| [Signature](#second-signature-transaction)           | `1`    | Register a Second Signature                           |  **✓**          |  5 RISE    |
| [Delegate](#register-delegate-transaction)           | `2`    | Register a Delegate                                   |  **✓**          |  25 RISE   |
| [Vote](#vote-transaction)                            | `3`    | Vote for Delegates                                    |  **✓**          |  1 RISE    |
| [Multisig](#multisignature-registration-transaction) | `4`    | Register a Multisignature                             |  **✓**          |  5 RISE    |
| DApp                                                 | `5`    | Register an Application                               |  -              |  -         |
| Transfer In                                          | `6`    | Transfer RISE from the Mainchain into a Sidechain     |  -              |  -         |
| Transfer Out                                         | `7`    | Transfer RISE out of a Sidechan back to the Mainchain |  -              |  -         |

[/table]

## Base Transaction

Although different transaction types have different payloads depending on their
function, some fields are shared among all of the transaction types. The
general structure of a transaction is as follows

[table]

| Name              | Size (bits) | Description                                 |
|-------------------|-------------|---------------------------------------------|
| Type              | `8`         | The Transaction type                        |
| Timestamp         | `32`        | Seconds since Epoch Time                    |
| Sender Public Key | `256`       | Public Key of the Sender                    |
| RecipientID       | `64`        | AccountID of the Receipient (Optional)      |
| Amount            | `64`        | Amount of RISE being transferred (Optional) |
| Other Fields      | `-`         | Transaction type specific fields (Optional) |
| Signature         | `512`       | First Signature                             |
| Second Signature  | `512`       | Second Signature (Optional)                 |
| TransactionID     | `64`        | Transaction ID                              |

[/table]

### Signing Transactions

All transactions must be signed by the sender before it can be accepted by the
nodes on the network. To sign a transaction first the sender must build the
transaction data block according to the transaction type. Then the sender
generates a hash of the transaction using the SHA-256 hashing algorithm. The
sender then generates a signature by passing the generated hash to an Ed25519
signature algorithm using his / her [link
href="pages/protocol/Identity!key-pairs"]key-pair[/link]. The generated
signature is then appended to the transaction data block. This process is
repeated if the sender has a second key, or if the account is a multisignature
account.

### TransactionIDs

The transactionID of a transaction is generated by computing the SHA-256 hash
of the transaction block after it has been signed, and then taking the first 8
bytes of the hash and reversing them.

### Broadcasting Transactions

Once the transaction data block has been built, signatures have been attached,
and a transactionID has been assigned, a fee will be attached to the
transaction according to the [Fee Schedule](#transactions) detailed in the
table above. The transaction can then be verified and then broadcasted to the
network. While the transaction may be present on the network, it will remain in
"Unconfirmed" status until it has been processed by a delegate. When the
transaction is broadcast to the network, it is sent as a JSON object using the
API.

## Send Transaction

A Send Transaction (or `Type 0` Transaction) is used to send RISE from one
account to another over the RISE network. To build the transaction data block
the data fields must be filled in as follows:

[table]

| Name              | Size (bits) | Value                                       |
|-------------------|-------------|---------------------------------------------|
| Type              | `8`         | `0`                                         |
| Timestamp         | `32`        | Seconds since Epoch Time                    |
| Sender Public Key | `256`       | Public Key of the Sender                    |
| RecipientID       | `64`        | AccountID of the Receipient (Optional)      |
| Amount            | `64`        | Amount of RISE being transferred            |

[/table]

After the transaction data block has been built, it can then be signed using
the Signature algorithm as described in [Signing
Transactions](#signing-transactions), and a TransactionID can be generated as
described in [TransactionIDs](#transaction-ids) above. The final step of the
process is to compute the current fee for the Transaction Type (in this case
0.1 RISE). After this, the transaction is ready to be broadcast to the network
as described in [Broadcasting Transactions](#broadcasting-transactions) above.

An example Send Transaction JSON object looks like the following:

```json
{
    "id": TransactionID,
    "type": 0,
    "timestamp": Seconds since Epoch,
    "senderPublicKey": Sender Public Key,
    "senderId": Sender RISE AccountID,
    "recipientId": Recipient RISE AccountID,
    "amount": Amount,
    "fee": 10000000,
    "signature": Signature
    ...
}
```

## Second Signature Transaction

A Second Signature Transaction (or `Type 1` Transaction) is used to add
a second signature to an address. The second signature adds a second layer of
security, by signing your transaction data block as well as your first
signature. To generate a second key-pair, the original passphrase as well as
a new passphrase must be used (see [link
href="pages/protocol/Identity!key-pairs"]Key Pair Generation[/link] for more
information). To build the transaction data block the following fields must be
filled in.

[table]

| Name              | Size (bits) | Value                                       |
|-------------------|-------------|---------------------------------------------|
| Type              | `8`         | `1`                                         |
| Timestamp         | `32`        | Seconds since Epoch Time                    |
| RecipientID       | `64`        | `0`                                         |
| Amount            | `64`        | `0`                                         |
| Sender Public Key | `256`       | Public Key of the Sender                    |
| Second Public Key | `256`       | Second Public Key of the Sender             |

[/table]

After the transaction data block has been built, it can then be signed by the
first public key-pair (not the second yet) using the Signature algorithm as
described in [Signing Transactions](#signing-transactions), and a TransactionID
can be generated as described in [TransactionIDs](#transaction-ids) above. The
final step of the process is to compute the current fee for the Transaction
Type (in this case 5 RISE). After this, the transaction is ready to be
broadcast to the network as described in [Broadcasting
Transactions](#broadcasting-transactions) above.

An example Second Signature Transaction JSON object looks like the following:

```json
{
    "id": TransactionID,
    "type": 1,
    "timestamp": Seconds since Epoch,
    "senderPublicKey": Sender Public Key,
    "senderId": Sender RISE AccountID,
    "recipientId": null,
    "amount": 0,
    "fee": 500000000,
    "signature": Signature,
    "asset": {
        "signature" {
            "publicKey": Sender Second Public Key to be associated
        }
    }
    ...
}
```

## Register Delegate Transaction

A Register Delegate Transaction (or `Type 2`) transaction is used to [link
href="pages/protocol/Consensus!delegates"]register an account as
a delegate[/link]. To register as a delegate the sender must choose a username
to register on the blockchain. The username can be between 1 and 20 characters.
To fill in the transaction data block therefore the following fields must be
filled in.

[table]

| Name              | Size (bits) | Value                                       |
|-------------------|-------------|---------------------------------------------|
| Type              | `8`         | `2`                                         |
| Timestamp         | `32`        | Seconds since Epoch Time                    |
| RecipientID       | `64`        | `0`                                         |
| Amount            | `64`        | `0`                                         |
| Sender Public Key | `256`       | Public Key of the Sender                    |
| Username          | `<=160`     | New username of the Delegate                |

[/table]

After the transaction data block has been built, it can then be signed using
the Signature algorithm as described in [Signing
Transactions](#signing-transactions), and a TransactionID can be generated as
described in [TransactionIDs](#transaction-ids) above. The final step of the
process is to compute the current fee for the Transaction Type (in this case 25
RISE). After this, the transaction is ready to be broadcast to the network as
described in [Broadcasting Transactions](#broadcasting-transactions) above.

An example Register Delegate Transaction JSON object looks like the following:

```json
{
    "id": TransactionID,
    "type": 2,
    "timestamp": Seconds since Epoch,
    "senderPublicKey": Sender Public Key,
    "senderId": Sender RISE AccountID,
    "recipientId": null,
    "amount": 0,
    "fee": 2500000000,
    "signature": Signature,
    "asset": {
        "delegate" {
            "username": Delegate username
        }
    }
    ...
}
```

## Vote Transaction

An Vote Transaction (or `Type 3` transaction) is used to add a vote or remove a vote for a delegate or delegates. A vote is formatted as follows:

* `'+' + Delegate Public Key` to add a vote for a delegate
* `'-' + Delegate Public Key` to remove a vote for a delegate

A Vote Transaction can hold a maximum of 33 votes, thereby a transaction block is built up as follows

[table]

| Name              | Size (bits)  | Value                                       |
|-------------------|--------------|---------------------------------------------|
| Type              | `8`          | `2`                                         |
| Timestamp         | `32`         | Seconds since Epoch Time                    |
| RecipientID       | `64`         | AccountID of the Sender                     |
| Amount            | `64`         | `0`                                         |
| Sender Public Key | `256`        | Public Key of the Sender                    |
| Delegate Votes    | `520 * <=33` | Array of Votes                              |

[/table]

After the transaction data block has been built, it can then be signed using
the Signature algorithm as described in [Signing
Transactions](#signing-transactions), and a TransactionID can be generated as
described in [TransactionIDs](#transaction-ids) above. The final step of the
process is to compute the current fee for the Transaction Type (in this case 1
RISE). After this, the transaction is ready to be broadcast to the network as
described in [Broadcasting Transactions](#broadcasting-transactions) above.

An example Vote Transaction JSON object looks like the following:

```json
{
    "id": TransactionID,
    "type": 3,
    "timestamp": Seconds since Epoch,
    "senderPublicKey": Sender Public Key,
    "senderId": Sender RISE AccountID,
    "recipientId": Sender RISE AccountID,
    "amount": 0,
    "fee": 100000000,
    "signature": Signature,
    "asset": {
        "votes" [
            Array of Delegate Vote Strings
        ]
    }
    ...
}
```

## Multisignature Registration Transaction

A Multisignature Registration Transaction (or `Type 4` Transaction) is used to
register a new [link
href="pages/protocol/Identity!multisignature-accounts"]Multisignature
Account[/link] which requires multiple signatures from various public keys. The
registration transaction specifies which key-pairs are allowed to sign the
transaction, as well as a minimum number of signatures for the transaction to
be considered valid. A maximum of 15 keys may be added to a key group for
a multisignature account. A list of public keys can be added or removed from
the multisignature account using the following format:

* `'+' + Public Key` to add the public key to the list of valid public keys
* `'-' + Public Key` to remove the public key from the list of valid public keys

In addition, the multisignature transaction must specify a lifetime for future
transactions. That is the number of hours a transaction can wait in the [link
href="pages/protocol/PeerToPeer!transaction-pool"]Transaction Pool[/link] for
valid keys to sign the transaction. Therefore to build the transaction the
following fields must be filled out.

[table]

| Name              | Size (bits)  | Value                                                    |
|-------------------|--------------|----------------------------------------------------------|
| Type              | `8`          | `2`                                                      |
| Timestamp         | `32`         | Seconds since Epoch Time                                 |
| RecipientID       | `64`         | AccountID of the Sender                                  |
| Amount            | `64`         | `0`                                                      |
| Sender Public Key | `256`        | Public Key of the Sender                                 |
| Min               | `8`          | Minimum number of Key Pairs needed to sign a Transaction |
| Lifetime          | `8`          | Time to live in Transaction Pool in Hours                |
| Keys Group        | `520 * <=15` | Public Keys to add or remove from Account                |

[/table]

After the transaction data block has been built, it can then be signed using
the Signature algorithm as described in [Signing
Transactions](#signing-transactions), and a TransactionID can be generated as
described in [TransactionIDs](#transaction-ids) above. The final step of the
process is to compute the current fee for the Transaction Type (in this case 5
RISE). After this, the transaction is ready to be broadcast to the network as
described in [Broadcasting Transactions](#broadcasting-transactions) above.

An example Multisignature Registration Transaction JSON object looks like the following:

```json
{
    "id": TransactionID,
    "type": 4,
    "timestamp": Seconds since Epoch,
    "senderPublicKey": Sender Public Key,
    "senderId": Sender RISE AccountID,
    "recipientId": Sender RISE AccountID,
    "amount": 0,
    "fee": 500000000,
    "signature": Signature,
    "asset": {
        "multisignature" {
            "min": Min,
            "lifetime": Lifetime,
            "keysgroup": [
                Array of Public Key Additions / Removals
            ]
        }
    }
    ...
}
```
